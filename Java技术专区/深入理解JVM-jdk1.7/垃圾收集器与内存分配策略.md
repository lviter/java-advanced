## 垃圾收集器与内存分配策略
Java与C++之间有一堵由***内存动态分配***和***垃圾收集***技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来
### 概述
垃圾收集（Garbage Collection,GC）
- 垃圾收集需要解决的问题
    - 哪些内存需要回收？
    - 什么时候回收？
    - 如何回收？
- 为什么需要了解垃圾回收
    - 需要排查各种内存溢出，泄露时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要堆垃圾收集以及内存分配实施必要的监控和调节
- 之前了解到了Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域是随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出执行者出栈和入栈的操作。每一个栈帧分配多少内存基本上在类结构确定后便已知，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。
- 而Java堆和方法区不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器关注的就是这部分内存。
### 对象已死吗
- 堆里存放着java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事要确定的就是哪些对象是可以被回收的（不可能再被任何途径使用的对象）。
- 判断对象是否存活的算法：
    1. 引用计数算法 
    2. 可达性分析算法
#### 引用计数算法
- 算法实现：给对象中添加一个引用计数器，每当由一个地方引用的时候，计数器值就加1；当引用失效时，计数器值减1；任何时刻计数器值为0的对象就是不可能再被使用的。
- java不用此算法原因：很难解决对象之间相互循环引用的问题
- 如下例子，`testGC()`方法，对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们
```yaml
-XX:+PrintGCDetails
```
```java
public class ReferenceCountingGC {
    public Object instance = null;
    private static final int _1MB = 1024 * 1024;
    /**
     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过
     */
    private byte[] bigSize = new byte[2 * _1MB];
    public static void testGC() {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
//假设在这行发生GC,objA和objB是否能被回收？
        System.gc();
    }
    public static void main(String[] args) {
        testGC();
    }
}
```
运行结果
```log
[GC (System.gc()) [PSYoungGen: 7966K->824K(75264K)] 7966K->832K(247296K), 0.0009400 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 824K->0K(75264K)] [ParOldGen: 8K->688K(172032K)] 832K->688K(247296K), [Metaspace: 3111K->3111K(1056768K)], 0.0047815 secs] [Times: user=0.09 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 75264K, used 1935K [0x000000076ca00000, 0x0000000771e00000, 0x00000007c0000000)
  eden space 64512K, 3% used [0x000000076ca00000,0x000000076cbe3fb8,0x0000000770900000)
  from space 10752K, 0% used [0x0000000770900000,0x0000000770900000,0x0000000771380000)
  to   space 10752K, 0% used [0x0000000771380000,0x0000000771380000,0x0000000771e00000)
 ParOldGen       total 172032K, used 688K [0x00000006c5e00000, 0x00000006d0600000, 0x000000076ca00000)
  object space 172032K, 0% used [0x00000006c5e00000,0x00000006c5eac260,0x00000006d0600000)
 Metaspace       used 3138K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 342K, capacity 388K, committed 512K, reserved 1048576K

Process finished with exit code 0
```
运行结果中可以清楚看到，GC日志中包含“7966K->824K(75264K)”，意味着虚拟机并没有因为这两个对象互相引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的
#### 可达性分析算法
- 在主流的商用程序语言（Java、C#，甚至包括前面提到的古老的Lisp）的主流实现中，都是称通过可达性分析（Reachability Analysis）来判定对象是否存活的
- 算法思路：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。
![](https://llhyoudao.oss-cn-shenzhen.aliyuncs.com/%E6%9C%89%E9%81%93%E4%BA%91/106.jpg?Expires=1609233366&OSSAccessKeyId=TMP.3KdAS4j2HLPJTzeZThLwmYWWmXqZpVTtrBJBW141Yw8hq9seU6CunAF9cFjcEmYuaWK5ZXNvi7sMB79LDKrhRsEXd4gEwP&Signature=hxwUQsFIofjV%2BuUcyWgr%2BWrETl0%3D)
如图，object5、object6、object7虽有关联，但是它们到GC roots时不可达的，所以被判定是可回收的对象
- Java语言中，可作为GC Roots的对象包括：
    - 虚拟机栈（栈帧中的本地变量表）中引用的对象
    - 方法区中类静态属性引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈中JNI(Native方法)引用的对象
#### 再谈引用
Java对引用的概念分为强引用（Strong Reference），软引用（Soft Reference），弱引用（Weak Reference），虚引用（Phantom Reference）4种。
SoftReference，WeakReference，PhantomReference
- 强引用在程序代码中普遍存在的，类似“Object obj=new Object()”这类的引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象
- 软引用描述一些有用但是非必需的对象，软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。
- 弱引用也是用来描述非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
- 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知

#### 生存还是死亡
即使在可达性分析算法中不可达的对象，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法


